{"version":3,"sources":["node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js","main.js"],"names":["VERSION","TAU","Math","PI","HALF_PI","RPM","ROOT24","C0","AudioMotionAnalyzer","constructor","container","options","audioCtx","_ready","_gradients","classic","bgColor","colorStops","pos","color","prism","rainbow","dir","_container","document","body","_defaultWidth","clientWidth","_defaultHeight","clientHeight","source","context","window","AudioContext","webkitAudioContext","err","AudioMotionError","createGain","analyzer","_analyzer","createAnalyser","splitter","_splitter","createChannelSplitter","merger","_merger","createChannelMerger","_input","_output","_sources","connectInput","i","connect","_outNodes","connectSpeakers","connectOutput","_energy","val","peak","hold","canvas","createElement","style","appendChild","_canvasCtx","getContext","ctx","onResize","_fsTimeout","setTimeout","_fsChanging","_setCanvas","ResizeObserver","observe","addEventListener","clearTimeout","unlockContext","state","resume","removeEventListener","_calcAux","_setProps","barSpace","_barSpace","value","fftSize","binCount","frequencyBinCount","_fftData","Uint8Array","_calcBars","gradient","_gradient","hasOwnProperty","_makeGrad","height","_height","h","width","_width","w","mode","_mode","loRes","_loRes","lumiBars","_lumiBars","_calcLeds","radial","_radial","spinSpeed","_spinSpeed","undefined","_spinAngle","reflexRatio","_reflexRatio","minFreq","_minFreq","maxFreq","_maxFreq","minDecibels","maxDecibels","showLeds","_showLeds","smoothing","smoothingTimeConstant","splitGradient","_splitGradient","stereo","_stereo","disconnect","length","_createScales","volume","gain","canvasCtx","connectedSources","connectedTo","energy","getEnergy","fsWidth","_fsWidth","fsHeight","_fsHeight","fps","_fps","isFullscreen","fullscreenElement","webkitFullscreenElement","isOctaveBands","_isOctaveBands","isLedDisplay","_isLedDisplay","isLumiBars","_isLumiBars","isOn","_runId","peakEnergy","pixelRatio","_pixelRatio","version","isHTML","HTMLMediaElement","node","createMediaElementSource","includes","push","disconnectInput","sources","Array","isArray","from","idx","indexOf","splice","destination","disconnectOutput","filter","e","startFreq","endFreq","presets","bass","lowMid","mid","highMid","treble","startBin","_freqToBin","endBin","chnCount","channel","registerGradient","name","trim","setCanvasSize","setFreqRange","min","max","setLedParams","params","maxLeds","spaceV","spaceH","_ledParams","setOptions","setSensitivity","toggleAnalyzer","started","cancelAnimationFrame","_frame","_time","performance","now","requestAnimationFrame","timestamp","_draw","toggleFullscreen","exitFullscreen","webkitExitFullscreen","requestFullscreen","webkitRequestFullscreen","_radius","_barSpacePx","_barWidth","_maximizeLeds","isDual","_channelHeight","_analyzerHeight","_channelGap","dPR","devicePixelRatio","screen","customParams","spaceVRatio","spaceHRatio","ledCount","analyzerHeight","minHeight","blockHeight","refRatio","_leds","canvasX","_scaleX","canvasR","_scaleR","isRadial","isStereo","channelHeight","channelGap","centerX","centerY","radius","radialXY","x","y","angle","cos","sin","radialPoly","moveTo","lineTo","ledSpaceH","ledSpaceV","ledHeight","showBgColor","overlay","currentEnergy","nBars","_bars","channelTop","channelBottom","analyzerBottom","clearRect","globalAlpha","bgAlpha","fillStyle","fillRect","reflexAlpha","showScaleY","scaleWidth","fontSize","mindB","maxdB","interval","font","textAlign","lineWidth","db","posY","even","labelY","fillText","strokeStyle","setLineDash","lineDashOffset","beginPath","stroke","_canvasGradient","fftData","getByteFrequencyData","bar","barHeight","endIdx","dataIdx","factor","prevBar","j","accel","adjWidth","posX","alpha","showPeaks","fullLeds","closePath","fillAlpha","arc","fill","reflexFit","reflexBright","setTransform","drawImage","showScaleX","save","translate","rotate","restore","elapsed","showFPS","size","round","onCanvasDraw","gradientHeight","analyzerRatio","currGradient","isHorizontal","grad","createRadialGradient","createLinearGradient","dual","addColorStop","offset","colorInfo","forEach","index","maxIndex","revIndex","freqLabels","scaleX","scaleR","scaleHeight","radialY","freq","label","_logWidth","log10","_minLog","adjAng","bars","binToFreq","bin","sampleRate","minLog","logWidth","notesPerBand","temperedScale","prevBin","prevIdx","nextBin","minIndex","lastPos","rounding","reason","newWidth","newHeight","lineJoin","_fsStatus","onCanvasResize","useDefaults","defaults","start","callbacks","validProps","Object","keys","concat","assign","prop","Error","code","message","audioElA","getElementById","audioElB","audiomotion","innerHeight","AnalyserA","AnalyserB","fileBlob","target","files","src","filename","$","replace","innerText","URL","createObjectURL","play"],"mappings":"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","file":"main.b52ab5d9.js","sourceRoot":"..","sourcesContent":["/**!\n * audioMotion-analyzer\n * High-resolution real-time graphic audio spectrum analyzer JS module\n *\n * @version 3.2.1\n * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>\n * @license AGPL-3.0-or-later\n */\n\nconst VERSION = '3.2.1';\n\n// internal constants\nconst TAU     = 2 * Math.PI,\n\t  HALF_PI = Math.PI / 2,\n\t  RPM     = TAU / 3600,           // angle increment per frame for one revolution per minute @60fps\n\t  ROOT24  = 2 ** ( 1 / 24 ),      // 24th root of 2\n\t  C0      = 440 * ROOT24 ** -114; // ~16.35 Hz\n\nexport default class AudioMotionAnalyzer {\n\n/**\n * CONSTRUCTOR\n *\n * @param {object} [container] DOM element where to insert the analyzer; if undefined, uses the document body\n * @param {object} [options]\n * @returns {object} AudioMotionAnalyzer object\n */\n\tconstructor( container, options = {} ) {\n\n\t\tthis._ready = false;\n\n\t\t// Gradient definitions\n\n\t\tthis._gradients = {\n\t\t\tclassic: {\n\t\t\t\tbgColor: '#111',\n\t\t\t\tcolorStops: [\n\t\t\t\t\t'hsl( 0, 100%, 50% )',\n\t\t\t\t\t{ pos: .6, color: 'hsl( 60, 100%, 50% )' },\n\t\t\t\t\t'hsl( 120, 100%, 50% )'\n\t\t\t\t]\n\t\t\t},\n\t\t\tprism:   {\n\t\t\t\tbgColor: '#111',\n\t\t\t\tcolorStops: [\n\t\t\t\t\t'hsl( 0, 100%, 50% )',\n\t\t\t\t\t'hsl( 60, 100%, 50% )',\n\t\t\t\t\t'hsl( 120, 100%, 50% )',\n\t\t\t\t\t'hsl( 180, 100%, 50% )',\n\t\t\t\t\t'hsl( 240, 100%, 50% )'\n\t\t\t\t]\n\t\t\t},\n\t\t\trainbow: {\n\t\t\t\tbgColor: '#111',\n\t\t\t\tdir: 'h',\n\t\t\t\tcolorStops: [\n\t\t\t\t\t'hsl( 0, 100%, 50% )',\n\t\t\t\t\t'hsl( 60, 100%, 50% )',\n\t\t\t\t\t'hsl( 120, 100%, 50% )',\n\t\t\t\t\t'hsl( 180, 100%, 47% )',\n\t\t\t\t\t'hsl( 240, 100%, 58% )',\n\t\t\t\t\t'hsl( 300, 100%, 50% )',\n\t\t\t\t\t'hsl( 360, 100%, 50% )'\n\t\t\t\t]\n\t\t\t},\n\t\t};\n\n\t\t// Set container\n\t\tthis._container = container || document.body;\n\n\t\t// Make sure we have minimal width and height dimensions in case of an inline container\n\t\tthis._defaultWidth  = this._container.clientWidth  || 640;\n\t\tthis._defaultHeight = this._container.clientHeight || 270;\n\n\t\t// Use audio context provided by user, or create a new one\n\n\t\tlet audioCtx;\n\n\t\tif ( options.source && ( audioCtx = options.source.context ) ) {\n\t\t\t// get audioContext from provided source audioNode\n\t\t}\n\t\telse if ( audioCtx = options.audioCtx ) {\n\t\t\t// use audioContext provided by user\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\taudioCtx = new ( window.AudioContext || window.webkitAudioContext )();\n\t\t\t}\n\t\t\tcatch( err ) {\n\t\t\t\tthrow new AudioMotionError( 'ERR_AUDIO_CONTEXT_FAIL', 'Could not create audio context. Web Audio API not supported?' );\n\t\t\t}\n\t\t}\n\n\t\t// make sure audioContext is valid\n\t\tif ( ! audioCtx.createGain )\n\t\t\tthrow new AudioMotionError( 'ERR_INVALID_AUDIO_CONTEXT', 'Provided audio context is not valid' );\n\n\t\t/*\n\t\t\tConnection routing:\n\t\t\t===================\n\n\t\t\tfor STEREO:                              +--->  analyzer[0]  ---+\n\t\t    \t                                     |                      |\n\t\t\t(source) --->  input  --->  splitter  ---+                      +--->  merger  --->  output  ---> (destination)\n\t\t    \t                                     |                      |\n\t\t        \t                                 +--->  analyzer[1]  ---+\n\n\t\t\tfor MONO:\n\n\t\t\t(source) --->  input  ----------------------->  analyzer[0]  --------------------->  output  ---> (destination)\n\n\t\t*/\n\n\t\t// create the analyzer nodes, channel splitter and merger, and gain nodes for input/output connections\n\t\tconst analyzer = this._analyzer = [ audioCtx.createAnalyser(), audioCtx.createAnalyser() ];\n\t\tconst splitter = this._splitter = audioCtx.createChannelSplitter(2);\n \t\tconst merger   = this._merger   = audioCtx.createChannelMerger(2);\n \t\tthis._input    = audioCtx.createGain();\n \t\tthis._output   = audioCtx.createGain();\n\n \t\t// initialize sources array and connect audio source if provided in the options\n\t\tthis._sources = [];\n\t\tif ( options.source )\n\t\t\tthis.connectInput( options.source );\n\n \t\t// connect splitter -> analyzers\n \t\tfor ( const i of [0,1] )\n\t\t\tsplitter.connect( analyzer[ i ], i );\n\n\t\t// connect merger -> output\n\t\tmerger.connect( this._output );\n\n\t\t// connect output -> destination (speakers)\n\t\tthis._outNodes = [];\n\t\tif ( options.connectSpeakers !== false )\n\t\t\tthis.connectOutput();\n\n\t\t// initialize object to save energy\n\t\tthis._energy = { val: 0, peak: 0, hold: 0 };\n\n\t\t// create analyzer canvas\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.style = 'max-width: 100%;';\n\t\tthis._container.appendChild( canvas );\n\t\tthis._canvasCtx = canvas.getContext('2d');\n\n\t\t// create auxiliary canvases for the X-axis and radial scale labels\n\t\tfor ( const ctx of [ '_scaleX', '_scaleR' ] )\n\t\t\tthis[ ctx ] = document.createElement('canvas').getContext('2d');\n\n\t\t// Update canvas size on container / window resize and fullscreen events\n\n\t\t// Fullscreen changes are handled quite differently across browsers:\n\t\t// 1. Chromium browsers will trigger a `resize` event followed by a `fullscreenchange`\n\t\t// 2. Firefox triggers the `fullscreenchange` first and then the `resize`\n\t\t// 3. Chrome on Android (TV) won't trigger a `resize` event, only `fullscreenchange`\n\t\t// 4. Safari won't trigger `fullscreenchange` events at all, and on iPadOS the `resize`\n\t\t//    event is triggered **on the window** only (last tested on iPadOS 14)\n\n\t\t// helper function for resize events\n\t\tconst onResize = () => {\n\t\t\tif ( ! this._fsTimeout ) {\n\t\t\t\t// delay the resize to prioritize a possible following `fullscreenchange` event\n\t\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\t\tif ( ! this._fsChanging ) {\n\t\t\t\t\t\tthis._setCanvas('resize');\n\t\t\t\t\t\tthis._fsTimeout = 0;\n\t\t\t\t\t}\n\t\t\t\t}, 60 );\n\t\t\t}\n\t\t}\n\n\t\t// if browser supports ResizeObserver, listen for resize on the container\n\t\tif ( window.ResizeObserver ) {\n\t\t\tconst resizeObserver = new ResizeObserver( onResize );\n\t\t\tresizeObserver.observe( this._container );\n\t\t}\n\n\t\t// listen for resize events on the window - required for fullscreen on iPadOS\n\t\twindow.addEventListener( 'resize', onResize );\n\n\t\t// listen for fullscreenchange events on the canvas - not available on Safari\n\t\tcanvas.addEventListener( 'fullscreenchange', () => {\n\t\t\t// set flag to indicate a fullscreen change in progress\n\t\t\tthis._fsChanging = true;\n\n\t\t\t// if there is a scheduled resize event, clear it\n\t\t\tif ( this._fsTimeout )\n\t\t\t\twindow.clearTimeout( this._fsTimeout );\n\n\t\t\t// update the canvas\n\t\t\tthis._setCanvas('fschange');\n\n\t\t\t// delay clearing the flag to prevent any shortly following resize event\n\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\tthis._fsChanging = false;\n\t\t\t\tthis._fsTimeout = 0;\n\t\t\t}, 60 );\n\t\t});\n\n\t\t// Resume audio context if in suspended state (browsers' autoplay policy)\n\t\tconst unlockContext = () => {\n\t\t\tif ( audioCtx.state == 'suspended' )\n\t\t\t\taudioCtx.resume();\n\t\t\twindow.removeEventListener( 'click', unlockContext );\n\t\t}\n\t\twindow.addEventListener( 'click', unlockContext );\n\n\t\t// initialize internal variables\n\t\tthis._calcAux();\n\n\t\t// Set configuration options and use defaults for any missing properties\n\t\tthis._setProps( options, true );\n\n\t\t// Finish canvas setup\n\t\tthis._ready = true;\n\t\tthis._setCanvas('create');\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PUBLIC PROPERTIES GETTERS AND SETTERS\n\t *\n\t * ==========================================================================\n\t */\n\n\t// Bar spacing (for octave bands modes)\n\n\tget barSpace() {\n\t\treturn this._barSpace;\n\t}\n\tset barSpace( value ) {\n\t\tthis._barSpace = +value || 0;\n\t\tthis._calcAux();\n\t}\n\n\t// FFT size\n\n\tget fftSize() {\n\t\treturn this._analyzer[0].fftSize;\n\t}\n\tset fftSize( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].fftSize = value;\n\t\tconst binCount = this._analyzer[0].frequencyBinCount;\n\t\tthis._fftData = [ new Uint8Array( binCount ), new Uint8Array( binCount ) ];\n\t\tthis._calcBars();\n\t}\n\n\t// Gradient\n\n\tget gradient() {\n\t\treturn this._gradient;\n\t}\n\tset gradient( value ) {\n\t\tif ( ! this._gradients.hasOwnProperty( value ) )\n\t\t\tthrow new AudioMotionError( 'ERR_UNKNOWN_GRADIENT', `Unknown gradient: '${value}'` );\n\n\t\tthis._gradient = value;\n\t\tthis._makeGrad();\n\t}\n\n\t// Canvas size\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\tset height( h ) {\n\t\tthis._height = h;\n\t\tthis._setCanvas('user');\n\t}\n\tget width() {\n\t\treturn this._width;\n\t}\n\tset width( w ) {\n\t\tthis._width = w;\n\t\tthis._setCanvas('user');\n\t}\n\n\t// Visualization mode\n\n\tget mode() {\n\t\treturn this._mode;\n\t}\n\tset mode( value ) {\n\t\tconst mode = value | 0;\n\t\tif ( mode >= 0 && mode <= 10 && mode != 9 ) {\n\t\t\tthis._mode = mode;\n\t\t\tthis._calcAux();\n\t\t\tthis._calcBars();\n\t\t\tthis._makeGrad();\n\t\t}\n\t\telse\n\t\t\tthrow new AudioMotionError( 'ERR_INVALID_MODE', `Invalid mode: ${value}` );\n\t}\n\n\t// Low-resolution mode\n\n\tget loRes() {\n\t\treturn this._loRes;\n\t}\n\tset loRes( value ) {\n\t\tthis._loRes = !! value;\n\t\tthis._setCanvas('lores');\n\t}\n\n\t// Luminance bars\n\n\tget lumiBars() {\n\t\treturn this._lumiBars;\n\t}\n\tset lumiBars( value ) {\n\t\tthis._lumiBars = !! value;\n\t\tthis._calcAux();\n\t\tthis._calcLeds();\n\t\tthis._makeGrad();\n\t}\n\n\t// Radial mode\n\n\tget radial() {\n\t\treturn this._radial;\n\t}\n\tset radial( value ) {\n\t\tthis._radial = !! value;\n\t\tthis._calcAux();\n\t\tthis._calcLeds();\n\t\tthis._makeGrad();\n\t}\n\n\t// Radial spin speed\n\n\tget spinSpeed() {\n\t\treturn this._spinSpeed;\n\t}\n\tset spinSpeed( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( this._spinSpeed === undefined || value == 0 )\n\t\t\tthis._spinAngle = -HALF_PI; // initialize or reset the rotation angle\n\t\tthis._spinSpeed = value;\n\t}\n\n\t// Reflex\n\n\tget reflexRatio() {\n\t\treturn this._reflexRatio;\n\t}\n\tset reflexRatio( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( value < 0 || value >= 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_REFLEX_OUT_OF_RANGE', `Reflex ratio must be >= 0 and < 1` );\n\t\telse {\n\t\t\tthis._reflexRatio = value;\n\t\t\tthis._calcAux();\n\t\t\tthis._makeGrad();\n\t\t\tthis._calcLeds();\n\t\t}\n\t}\n\n\t// Current frequency range\n\n\tget minFreq() {\n\t\treturn this._minFreq;\n\t}\n\tset minFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_FREQUENCY_TOO_LOW', `Frequency values must be >= 1` );\n\t\telse {\n\t\t\tthis._minFreq = value;\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\tget maxFreq() {\n\t\treturn this._maxFreq;\n\t}\n\tset maxFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_FREQUENCY_TOO_LOW', `Frequency values must be >= 1` );\n\t\telse {\n\t\t\tthis._maxFreq = value;\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\t// Analyzer's sensitivity\n\n\tget minDecibels() {\n\t\treturn this._analyzer[0].minDecibels;\n\t}\n\tset minDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].minDecibels = value;\n\t}\n\tget maxDecibels() {\n\t\treturn this._analyzer[0].maxDecibels;\n\t}\n\tset maxDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].maxDecibels = value;\n\t}\n\n\t// LEDs effect\n\n\tget showLeds() {\n\t\treturn this._showLeds;\n\t}\n\tset showLeds( value ) {\n\t\tthis._showLeds = !! value;\n\t\tthis._calcAux();\n\t}\n\n\t// Analyzer's smoothing time constant\n\n\tget smoothing() {\n\t\treturn this._analyzer[0].smoothingTimeConstant;\n\t}\n\tset smoothing( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].smoothingTimeConstant = value;\n\t}\n\n\t// Split gradient (in stereo mode)\n\n\tget splitGradient() {\n\t\treturn this._splitGradient;\n\t}\n\tset splitGradient( value ) {\n\t\tthis._splitGradient = !! value;\n\t\tthis._makeGrad();\n\t}\n\n\t// Stereo\n\n\tget stereo() {\n\t\treturn this._stereo;\n\t}\n\tset stereo( value ) {\n\t\tthis._stereo = !! value;\n\n\t\t// update node connections\n\t\tthis._input.disconnect();\n\t\tthis._input.connect( this._stereo ? this._splitter : this._analyzer[0] );\n\t\tthis._analyzer[0].disconnect();\n\t\tif ( this._outNodes.length ) // connect analyzer only if the output is connected to other nodes\n\t\t\tthis._analyzer[0].connect( this._stereo ? this._merger : this._output );\n\n\t\t// update properties affected by stereo\n\t\tthis._calcAux();\n\t\tthis._createScales();\n\t\tthis._calcLeds();\n\t\tthis._makeGrad();\n\t}\n\n\t// Volume\n\n\tget volume() {\n\t\treturn this._output.gain.value;\n\t}\n\tset volume( value ) {\n\t\tthis._output.gain.value = value;\n\t}\n\n\t// Read only properties\n\n\tget audioCtx() {\n\t\treturn this._input.context;\n\t}\n\tget canvas() {\n\t\treturn this._canvasCtx.canvas;\n\t}\n\tget canvasCtx() {\n\t\treturn this._canvasCtx;\n\t}\n\tget connectedSources() {\n\t\treturn this._sources;\n\t}\n\tget connectedTo() {\n\t\treturn this._outNodes;\n\t}\n\tget energy() {\n\t\t// DEPRECATED - to be removed in v4.0.0\n\t\treturn this.getEnergy();\n\t}\n\tget fsWidth() {\n\t\treturn this._fsWidth;\n\t}\n\tget fsHeight() {\n\t\treturn this._fsHeight;\n\t}\n\tget fps() {\n\t\treturn this._fps;\n\t}\n\tget isFullscreen() {\n\t\treturn ( document.fullscreenElement || document.webkitFullscreenElement ) === this.canvas;\n\t}\n\tget isOctaveBands() {\n\t\treturn this._isOctaveBands;\n\t}\n\tget isLedDisplay() {\n\t\treturn this._isLedDisplay;\n\t}\n\tget isLumiBars() {\n\t\treturn this._isLumiBars;\n\t}\n\tget isOn() {\n\t\treturn this._runId !== undefined;\n\t}\n\tget peakEnergy() {\n\t\t// DEPRECATED - to be removed in v4.0.0\n\t\treturn this.getEnergy('peak');\n\t}\n\tget pixelRatio() {\n\t\treturn this._pixelRatio;\n\t}\n\tstatic get version() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * ==========================================================================\n     *\n\t * PUBLIC METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Connects an HTML media element or audio node to the analyzer\n\t *\n\t * @param {object} an instance of HTMLMediaElement or AudioNode\n\t * @returns {object} a MediaElementAudioSourceNode object if created from HTML element, or the same input object otherwise\n\t */\n\tconnectInput( source ) {\n\t\tconst isHTML = source instanceof HTMLMediaElement;\n\n\t\tif ( ! ( isHTML || source.connect ) )\n\t\t\tthrow new AudioMotionError( 'ERR_INVALID_AUDIO_SOURCE', 'Audio source must be an instance of HTMLMediaElement or AudioNode' );\n\n\t\t// if source is an HTML element, create an audio node for it; otherwise, use the provided audio node\n\t\tconst node = isHTML ? this.audioCtx.createMediaElementSource( source ) : source;\n\n\t\tif ( ! this._sources.includes( node ) ) {\n\t\t\tnode.connect( this._input );\n\t\t\tthis._sources.push( node );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Disconnects audio sources from the analyzer\n\t *\n\t * @param [{object|array}] a connected AudioNode object or an array of such objects; if undefined, all connected nodes are disconnected\n\t */\n\tdisconnectInput( sources ) {\n\t\tif ( ! sources )\n\t\t\tsources = Array.from( this._sources );\n\t\telse if ( ! Array.isArray( sources ) )\n\t\t\tsources = [ sources ];\n\n\t\tfor ( const node of sources ) {\n\t\t\tconst idx = this._sources.indexOf( node );\n\t\t\tif ( idx >= 0 ) {\n\t\t\t\tnode.disconnect( this._input );\n\t\t\t\tthis._sources.splice( idx, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Connects the analyzer output to another audio node\n\t *\n\t * @param [{object}] an AudioNode; if undefined, the output is connected to the audio context destination (speakers)\n\t */\n\tconnectOutput( node = this.audioCtx.destination ) {\n\t\tif ( this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.connect( node );\n\t\tthis._outNodes.push( node );\n\n\t\t// when connecting the first node, also connect the analyzer nodes to the merger / output nodes\n\t\tif ( this._outNodes.length == 1 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].connect( ( ! this._stereo && ! i ? this._output : this._merger ), 0, i );\n\t\t}\n\t}\n\n\t/**\n\t * Disconnects the analyzer output from other audio nodes\n\t *\n\t * @param [{object}] a connected AudioNode object; if undefined, all connected nodes are disconnected\n\t */\n\tdisconnectOutput( node ) {\n\t\tif ( node && ! this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.disconnect( node );\n\t\tthis._outNodes = node ? this._outNodes.filter( e => e !== node ) : [];\n\n\t\t// if disconnected from all nodes, also disconnect the analyzer nodes so they keep working on Chromium\n\t\t// see https://github.com/hvianna/audioMotion-analyzer/issues/13#issuecomment-808764848\n\t\tif ( this._outNodes.length == 0 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].disconnect();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the energy of a frequency, or average energy of a range of frequencies\n\t *\n\t * @param [{number|string}] single or initial frequency (Hz), or preset name; if undefined, returns the overall energy\n\t * @param [{number}] ending frequency (Hz)\n\t * @returns {number|null} energy value (0 to 1) or null, if the specified preset is unknown\n\t */\n\tgetEnergy( startFreq, endFreq ) {\n\t\tif ( startFreq === undefined )\n\t\t\treturn this._energy.val;\n\n\t\t// if startFreq is a string, check for presets\n\t\tif ( startFreq != ( startFreq | 0 ) ) {\n\t\t\tif ( startFreq == 'peak' )\n\t\t\t\treturn this._energy.peak;\n\n\t\t\tconst presets = {\n\t\t\t\tbass:    [ 20, 250 ],\n\t\t\t\tlowMid:  [ 250, 500 ],\n\t\t\t\tmid:     [ 500, 2e3 ],\n\t\t\t\thighMid: [ 2e3, 4e3 ],\n\t\t\t\ttreble:  [ 4e3, 16e3 ]\n\t\t\t}\n\n\t\t\tif ( ! presets[ startFreq ] )\n\t\t\t\treturn null;\n\n\t\t\t[ startFreq, endFreq ] = presets[ startFreq ];\n\t\t}\n\n\t\tconst startBin = this._freqToBin( startFreq ),\n\t\t      endBin   = endFreq ? this._freqToBin( endFreq ) : startBin,\n\t\t      chnCount = this._stereo + 1;\n\n\t\tlet energy = 0;\n\t\tfor ( let channel = 0; channel < chnCount; channel++ ) {\n\t\t\tfor ( let i = startBin; i <= endBin; i++ )\n\t\t\t\tenergy += this._fftData[ channel ][ i ];\n\t\t}\n\n\t\treturn energy / ( endBin - startBin + 1 ) / chnCount / 255;\n\t}\n\n\t/**\n\t * Registers a custom gradient\n\t *\n\t * @param {string} name\n\t * @param {object} options\n\t */\n\tregisterGradient( name, options ) {\n\t\tif ( typeof name !== 'string' || name.trim().length == 0 )\n\t\t\tthrow new AudioMotionError( 'ERR_GRADIENT_INVALID_NAME', 'Gradient name must be a non-empty string' );\n\n\t\tif ( typeof options !== 'object' )\n\t\t\tthrow new AudioMotionError( 'ERR_GRADIENT_NOT_AN_OBJECT', 'Gradient options must be an object' );\n\n\t\tif ( options.colorStops === undefined || options.colorStops.length < 2 )\n\t\t\tthrow new AudioMotionError( 'ERR_GRADIENT_MISSING_COLOR', 'Gradient must define at least two colors' );\n\n\t\tthis._gradients[ name ] = {};\n\n\t\tif ( options.bgColor !== undefined )\n\t\t\tthis._gradients[ name ].bgColor = options.bgColor;\n\t\telse\n\t\t\tthis._gradients[ name ].bgColor = '#111';\n\n\t\tif ( options.dir !== undefined )\n\t\t\tthis._gradients[ name ].dir = options.dir;\n\n\t\tthis._gradients[ name ].colorStops = options.colorStops;\n\t}\n\n\t/**\n\t * Set dimensions of analyzer's canvas\n\t *\n\t * @param {number} w width in pixels\n\t * @param {number} h height in pixels\n\t */\n\tsetCanvasSize( w, h ) {\n\t\tthis._width = w;\n\t\tthis._height = h;\n\t\tthis._setCanvas('user');\n\t}\n\n\t/**\n\t * Set desired frequency range\n\t *\n\t * @param {number} min lowest frequency represented in the x-axis\n\t * @param {number} max highest frequency represented in the x-axis\n\t */\n\tsetFreqRange( min, max ) {\n\t\tif ( min < 1 || max < 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_FREQUENCY_TOO_LOW', `Frequency values must be >= 1` );\n\t\telse {\n\t\t\tthis._minFreq = Math.min( min, max );\n\t\t\tthis._maxFreq = Math.max( min, max );\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\t/**\n\t * Set custom parameters for LED effect\n\t * If called with no arguments or if any property is invalid, clears any previous custom parameters\n\t *\n\t * @param {object} [params]\n\t */\n\tsetLedParams( params ) {\n\t\tlet maxLeds, spaceV, spaceH;\n\n\t\t// coerce parameters to Number; `NaN` results are rejected in the condition below\n\t\tif ( params ) {\n\t\t\tmaxLeds = params.maxLeds | 0, // ensure integer\n\t\t\tspaceV  = +params.spaceV,\n\t\t\tspaceH  = +params.spaceH;\n\t\t}\n\n\t\tthis._ledParams = maxLeds > 0 && spaceV > 0 && spaceH >= 0 ? [ maxLeds, spaceV, spaceH ] : undefined;\n\t\tthis._calcLeds();\n\t}\n\n\t/**\n\t * Shorthand function for setting several options at once\n\t *\n\t * @param {object} options\n\t */\n\tsetOptions( options ) {\n\t\tthis._setProps( options );\n\t}\n\n\t/**\n\t * Adjust the analyzer's sensitivity\n\t *\n\t * @param {number} min minimum decibels value\n\t * @param {number} max maximum decibels value\n\t */\n\tsetSensitivity( min, max ) {\n\t\tfor ( const i of [0,1] ) {\n\t\t\tthis._analyzer[ i ].minDecibels = Math.min( min, max );\n\t\t\tthis._analyzer[ i ].maxDecibels = Math.max( min, max );\n\t\t}\n\t}\n\n\t/**\n\t * Start / stop canvas animation\n\t *\n\t * @param {boolean} [value] if undefined, inverts the current status\n\t * @returns {boolean} resulting status after the change\n\t */\n\ttoggleAnalyzer( value ) {\n\t\tconst started = this.isOn;\n\n\t\tif ( value === undefined )\n\t\t\tvalue = ! started;\n\n\t\tif ( started && ! value ) {\n\t\t\tcancelAnimationFrame( this._runId );\n\t\t\tthis._runId = undefined;\n\t\t}\n\t\telse if ( ! started && value ) {\n\t\t\tthis._frame = this._fps = 0;\n\t\t\tthis._time = performance.now();\n\t\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) );\n\t\t}\n\n\t\treturn this.isOn;\n\t}\n\n\t/**\n\t * Toggles canvas full-screen mode\n\t */\n\ttoggleFullscreen() {\n\t\tif ( this.isFullscreen ) {\n\t\t\tif ( document.exitFullscreen )\n\t\t\t\tdocument.exitFullscreen();\n\t\t\telse if ( document.webkitExitFullscreen )\n\t\t\t\tdocument.webkitExitFullscreen();\n\t\t}\n\t\telse {\n\t\t\tconst canvas = this.canvas;\n\t\t\tif ( canvas.requestFullscreen )\n\t\t\t\tcanvas.requestFullscreen();\n\t\t\telse if ( canvas.webkitRequestFullscreen )\n\t\t\t\tcanvas.webkitRequestFullscreen();\n\t\t}\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PRIVATE METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Calculate auxiliary values and flags\n\t */\n\t_calcAux() {\n\t\tconst canvas = this.canvas;\n\n\t\tthis._radius         = canvas.height * ( this._stereo ? .375 : .125 ) | 0;\n\t\tthis._barSpacePx     = Math.min( this._barWidth - 1, ( this._barSpace > 0 && this._barSpace < 1 ) ? this._barWidth * this._barSpace : this._barSpace );\n\t\tthis._isOctaveBands  = ( this._mode % 10 != 0 );\n\t\tthis._isLedDisplay   = ( this._showLeds && this._isOctaveBands && ! this._radial );\n\t\tthis._isLumiBars     = ( this._lumiBars && this._isOctaveBands && ! this._radial );\n\t\tthis._maximizeLeds   = ! this._stereo || this._reflexRatio > 0 && ! this._isLumiBars;\n\n\t\tconst isDual = this._stereo && ! this._radial;\n\t\tthis._channelHeight  = canvas.height - ( isDual && ! this._isLedDisplay ? .5 : 0 ) >> isDual;\n\t\tthis._analyzerHeight = this._channelHeight * ( this._isLumiBars || this._radial ? 1 : 1 - this._reflexRatio ) | 0;\n\n\t\t// channelGap is **0** if isLedDisplay == true (LEDs already have spacing); **1** if canvas height is odd (windowed); **2** if it's even\n\t\t// TODO: improve this, make it configurable?\n\t\tthis._channelGap     = isDual ? canvas.height - this._channelHeight * 2 : 0;\n\t}\n\n\t/**\n\t * Calculate attributes for the vintage LEDs effect, based on visualization mode and canvas resolution\n\t */\n\t_calcLeds() {\n\t\tif ( ! this._isOctaveBands || ! this._ready )\n\t\t\treturn;\n\n\t\t// adjustment for high pixel-ratio values on low-resolution screens (Android TV)\n\t\tconst dPR = this._pixelRatio / ( window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1 );\n\n\t\tconst params = [ [],\n\t\t\t[ 128,  3, .45  ], // mode 1\n\t\t\t[ 128,  4, .225 ], // mode 2\n\t\t\t[  96,  6, .225 ], // mode 3\n\t\t\t[  80,  6, .225 ], // mode 4\n\t\t\t[  80,  6, .125 ], // mode 5\n\t\t\t[  64,  6, .125 ], // mode 6\n\t\t\t[  48,  8, .125 ], // mode 7\n\t\t\t[  24, 16, .125 ], // mode 8\n\t\t];\n\n\t\t// use custom LED parameters if set, or the default parameters for the current mode\n\t\tconst customParams = this._ledParams,\n\t\t\t  [ maxLeds, spaceVRatio, spaceHRatio ] = customParams || params[ this._mode ];\n\n\t\tlet ledCount, spaceV,\n\t\t\tanalyzerHeight = this._analyzerHeight;\n\n\t\tif ( customParams ) {\n\t\t\tconst minHeight = 2 * dPR;\n\t\t\tlet blockHeight;\n\t\t\tledCount = maxLeds + 1;\n\t\t\tdo {\n\t\t\t\tledCount--;\n\t\t\t\tblockHeight = analyzerHeight / ledCount / ( 1 + spaceVRatio );\n\t\t\t\tspaceV = blockHeight * spaceVRatio;\n\t\t\t} while ( ( blockHeight < minHeight || spaceV < minHeight ) && ledCount > 1 );\n\t\t}\n\t\telse {\n\t\t\t// calculate vertical spacing - aim for the reference ratio, but make sure it's at least 2px\n\t\t\tconst refRatio = 540 / spaceVRatio;\n\t\t\tspaceV = Math.min( spaceVRatio * dPR, Math.max( 2, analyzerHeight / refRatio + .1 | 0 ) );\n\t\t}\n\n\t\t// remove the extra spacing below the last line of LEDs\n\t\tif ( this._maximizeLeds )\n\t\t\tanalyzerHeight += spaceV;\n\n\t\t// recalculate the number of leds, considering the effective spaceV\n\t\tif ( ! customParams )\n\t\t\tledCount = Math.min( maxLeds, analyzerHeight / ( spaceV * 2 ) | 0 );\n\n\t\tthis._leds = [\n\t\t\tledCount,\n\t\t\tspaceHRatio >= 1 ? spaceHRatio : this._barWidth * spaceHRatio, // spaceH\n\t\t\tspaceV,\n\t\t\tanalyzerHeight / ledCount - spaceV // ledHeight\n\t\t];\n\t}\n\n\t/**\n\t * Redraw the canvas\n\t * this is called 60 times per second by requestAnimationFrame()\n\t */\n\t_draw( timestamp ) {\n\t\tconst ctx            = this._canvasCtx,\n\t\t\t  canvas         = ctx.canvas,\n\t\t\t  canvasX        = this._scaleX.canvas,\n\t\t\t  canvasR        = this._scaleR.canvas,\n\t\t\t  energy         = this._energy,\n\t\t\t  isOctaveBands  = this._isOctaveBands,\n\t\t\t  isLedDisplay   = this._isLedDisplay,\n\t\t\t  isLumiBars     = this._isLumiBars,\n\t\t\t  isRadial       = this._radial,\n\t\t\t  isStereo       = this._stereo,\n\t\t\t  mode           = this._mode,\n\t\t\t  channelHeight  = this._channelHeight,\n\t\t\t  channelGap     = this._channelGap,\n\t\t\t  analyzerHeight = this._analyzerHeight;\n\n\t\t// radial related constants\n\t\tconst centerX        = canvas.width >> 1,\n\t\t\t  centerY        = canvas.height >> 1,\n\t\t\t  radius         = this._radius;\n\n\t\tif ( energy.val > 0 )\n\t\t\tthis._spinAngle += this._spinSpeed * RPM;\n\n\t\t// helper function - convert planar X,Y coordinates to radial coordinates\n\t\tconst radialXY = ( x, y ) => {\n\t\t\tconst height = radius + y,\n\t\t\t\t  angle  = TAU * ( x / canvas.width ) + this._spinAngle;\n\n\t\t\treturn [ centerX + height * Math.cos( angle ), centerY + height * Math.sin( angle ) ];\n\t\t}\n\n\t\t// helper function - draw a polygon of width `w` and height `h` at (x,y) in radial mode\n\t\tconst radialPoly = ( x, y, w, h ) => {\n\t\t\tctx.moveTo( ...radialXY( x, y ) );\n\t\t\tctx.lineTo( ...radialXY( x, y + h ) );\n\t\t\tctx.lineTo( ...radialXY( x + w, y + h ) );\n\t\t\tctx.lineTo( ...radialXY( x + w, y ) );\n\t\t}\n\n\t\t// LED attributes\n\t\tconst [ ledCount, ledSpaceH, ledSpaceV, ledHeight ] = this._leds || [];\n\n\t\t// select background color\n\t\tconst bgColor = ( ! this.showBgColor || isLedDisplay && ! this.overlay ) ? '#000' : this._gradients[ this._gradient ].bgColor;\n\n\t\t// compute the effective bar width, considering the selected bar spacing\n\t\t// if led effect is active, ensure at least the spacing from led definitions\n\t\tlet width = this._barWidth - ( ! isOctaveBands ? 0 : Math.max( isLedDisplay ? ledSpaceH : 0, this._barSpacePx ) );\n\n\t\t// make sure width is integer for pixel accurate calculation, when no bar spacing is required\n\t\tif ( this._barSpace == 0 && ! isLedDisplay )\n\t\t\twidth |= 0;\n\n\t\tlet currentEnergy = 0;\n\n\t\tconst nBars = this._bars.length;\n\n\t\tfor ( let channel = 0; channel < isStereo + 1; channel++ ) {\n\n\t\t\tconst channelTop     = channelHeight * channel + channelGap * channel,\n\t\t\t\t  channelBottom  = channelTop + channelHeight,\n\t\t\t\t  analyzerBottom = channelTop + analyzerHeight - ( isLedDisplay && ! this._maximizeLeds ? ledSpaceV : 0 );\n\n\t\t\t// clear the channel area, if in overlay mode\n\t\t\t// this is done per channel to clear any residue below 0 off the top channel (especially in line graph mode with lineWidth > 1)\n\t\t\tif ( this.overlay )\n\t\t\t\tctx.clearRect( 0, channelTop - channelGap, canvas.width, channelHeight + channelGap );\n\n\t\t\t// fill the analyzer background if needed (not overlay or overlay + showBgColor)\n\t\t\tif ( ! this.overlay || this.showBgColor ) {\n\t\t\t\tif ( this.overlay )\n\t\t\t\t\tctx.globalAlpha = this.bgAlpha;\n\n\t\t\t\tctx.fillStyle = bgColor;\n\n\t\t\t\t// exclude the reflection area when overlay is true and reflexAlpha == 1 (avoids alpha over alpha difference, in case bgAlpha < 1)\n\t\t\t\tif ( ! isRadial || channel == 0 )\n\t\t\t\t\tctx.fillRect( 0, channelTop - channelGap, canvas.width, ( this.overlay && this.reflexAlpha == 1 ? analyzerHeight : channelHeight ) + channelGap );\n\n\t\t\t\tctx.globalAlpha = 1;\n\t\t\t}\n\n\t\t\t// draw dB scale (Y-axis)\n\t\t\tif ( this.showScaleY && ! isLumiBars && ! isRadial ) {\n\t\t\t\tconst scaleWidth = canvasX.height,\n\t\t\t\t\t  fontSize   = scaleWidth >> 1,\n\t\t\t\t\t  mindB      = this._analyzer[0].minDecibels,\n\t\t\t\t\t  maxdB      = this._analyzer[0].maxDecibels,\n\t\t\t\t\t  interval   = analyzerHeight / ( maxdB - mindB );\n\n\t\t\t\tctx.fillStyle = '#888';\n\t\t\t\tctx.font = `${fontSize}px sans-serif`;\n\t\t\t\tctx.textAlign = 'right';\n\t\t\t\tctx.lineWidth = 1;\n\n\t\t\t\tfor ( let db = maxdB; db > mindB; db -= 5 ) {\n\t\t\t\t\tconst posY = channelTop + ( maxdB - db ) * interval,\n\t\t\t\t\t\t  even = ( db % 2 == 0 ) | 0;\n\n\t\t\t\t\tif ( even ) {\n\t\t\t\t\t\tconst labelY = posY + fontSize * ( posY == channelTop ? .8 : .35 );\n\t\t\t\t\t\tctx.fillText( db, scaleWidth * .85, labelY );\n\t\t\t\t\t\tctx.fillText( db, canvas.width - scaleWidth * .1, labelY );\n\t\t\t\t\t\tctx.strokeStyle = '#888';\n\t\t\t\t\t\tctx.setLineDash([2,4]);\n\t\t\t\t\t\tctx.lineDashOffset = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tctx.strokeStyle = '#555';\n\t\t\t\t\t\tctx.setLineDash([2,8]);\n\t\t\t\t\t\tctx.lineDashOffset = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo( scaleWidth * even, ~~posY + .5 ); // for sharp 1px line (https://stackoverflow.com/a/13879402/2370385)\n\t\t\t\t\tctx.lineTo( canvas.width - scaleWidth * even, ~~posY + .5 );\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\t// restore line properties\n\t\t\t\tctx.setLineDash([]);\n\t\t\t\tctx.lineDashOffset = 0;\n\t\t\t}\n\n\t\t\t// set line width and dash for LEDs effect\n\t\t\tif ( isLedDisplay ) {\n\t\t\t\tctx.setLineDash( [ ledHeight, ledSpaceV ] );\n\t\t\t\tctx.lineWidth = width;\n\t\t\t}\n\n\t\t\t// set selected gradient for fill and stroke\n\t\t\tctx.fillStyle = ctx.strokeStyle = this._canvasGradient;\n\n\t\t\t// get a new array of data from the FFT\n\t\t\tconst fftData = this._fftData[ channel ];\n\t\t\tthis._analyzer[ channel ].getByteFrequencyData( fftData );\n\n\t\t\t// start drawing path\n\t\t\tctx.beginPath();\n\n\t\t\t// draw bars / lines\n\n\t\t\tfor ( let i = 0; i < nBars; i++ ) {\n\n\t\t\t\tlet bar       = this._bars[ i ],\n\t\t\t\t\tbarHeight = 0;\n\n\t\t\t\tif ( bar.endIdx == 0 ) { // single FFT bin\n\t\t\t\t\tbarHeight = fftData[ bar.dataIdx ];\n\t\t\t\t\t// perform value interpolation when several bars share the same bin, to generate a smooth curve\n\t\t\t\t\tif ( bar.factor ) {\n\t\t\t\t\t\tconst prevBar = bar.dataIdx ? fftData[ bar.dataIdx - 1 ] : barHeight;\n\t\t\t\t\t\tbarHeight = prevBar + ( barHeight - prevBar ) * bar.factor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { \t\t\t\t\t// range of bins\n\t\t\t\t\t// use the highest value in the range\n\t\t\t\t\tfor ( let j = bar.dataIdx; j <= bar.endIdx; j++ )\n\t\t\t\t\t\tbarHeight = Math.max( barHeight, fftData[ j ] );\n\t\t\t\t}\n\n\t\t\t\tbarHeight /= 255;\n\t\t\t\tcurrentEnergy += barHeight;\n\n\t\t\t\t// set opacity for lumi bars before barHeight value is normalized\n\t\t\t\tif ( isLumiBars )\n\t\t\t\t\tctx.globalAlpha = barHeight;\n\n\t\t\t\tif ( isLedDisplay ) { // normalize barHeight to match one of the \"led\" elements\n\t\t\t\t\tbarHeight = ( barHeight * ledCount | 0 ) * ( ledHeight + ledSpaceV ) - ledSpaceV;\n\t\t\t\t\tif ( barHeight < 0 )\n\t\t\t\t\t\tbarHeight = 0; // prevent showing leds below 0 when overlay and reflex are active\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbarHeight = barHeight * ( isRadial ? centerY - radius : analyzerHeight ) | 0;\n\n\t\t\t\tif ( barHeight >= bar.peak[ channel ] ) {\n\t\t\t\t\tbar.peak[ channel ] = barHeight;\n\t\t\t\t\tbar.hold[ channel ] = 30; // set peak hold time to 30 frames (0.5s)\n\t\t\t\t\tbar.accel[ channel ] = 0;\n\t\t\t\t}\n\n\t\t\t\tif ( isRadial && channel == 1 )\n\t\t\t\t\tbarHeight *= -1;\n\n\t\t\t\tlet adjWidth = width,    // bar width may need small adjustments for some bars, when barSpace == 0\n\t\t\t\t\tposX     = bar.posX;\n\n\t\t\t\t// Draw current bar or line segment\n\n\t\t\t\tif ( mode == 10 ) {\n\t\t\t\t\tif ( isRadial ) {\n\t\t\t\t\t\t// in radial graph mode, use value of previous FFT bin (if available) as the initial amplitude\n\t\t\t\t\t\tif ( i == 0 && bar.dataIdx && bar.posX )\n\t\t\t\t\t\t\tctx.lineTo( ...radialXY( 0, fftData[ bar.dataIdx - 1 ] / 255 * ( centerY - radius ) * ( channel == 1 ? -1 : 1 ) ) );\n\t\t\t\t\t\t// draw line to current point, avoiding overlapping wrap-around frequencies\n\t\t\t\t\t\tif ( bar.posX >= 0 )\n\t\t\t\t\t\t\tctx.lineTo( ...radialXY( bar.posX, barHeight ) );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ( i == 0 ) {\n\t\t\t\t\t\t\t// in linear mode, start the line off screen\n\t\t\t\t\t\t\tctx.moveTo( -this.lineWidth, analyzerBottom );\n\t\t\t\t\t\t\t// use value of previous FFT bin\n\t\t\t\t\t\t\tif ( bar.dataIdx )\n\t\t\t\t\t\t\t\tctx.lineTo( -this.lineWidth, analyzerBottom - fftData[ bar.dataIdx - 1 ] / 255 * analyzerHeight );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// draw line to current point\n\t\t\t\t\t\tctx.lineTo( bar.posX, analyzerBottom - barHeight );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( mode > 0 ) {\n\t\t\t\t\t\tif ( isLedDisplay )\n\t\t\t\t\t\t\tposX += Math.max( ledSpaceH / 2, this._barSpacePx / 2 );\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( this._barSpace == 0 ) {\n\t\t\t\t\t\t\t\tposX |= 0;\n\t\t\t\t\t\t\t\tif ( i > 0 && posX > this._bars[ i - 1 ].posX + width ) {\n\t\t\t\t\t\t\t\t\tposX--;\n\t\t\t\t\t\t\t\t\tadjWidth++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tposX += this._barSpacePx / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isLedDisplay ) {\n\t\t\t\t\t\tconst x = posX + width / 2;\n\t\t\t\t\t\t// draw \"unlit\" leds\n\t\t\t\t\t\tif ( this.showBgColor && ! this.overlay ) {\n\t\t\t\t\t\t\tconst alpha = ctx.globalAlpha;\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo( x, channelTop );\n\t\t\t\t\t\t\tctx.lineTo( x, analyzerBottom );\n\t\t\t\t\t\t\tctx.strokeStyle = '#7f7f7f22';\n\t\t\t\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t\t// restore properties\n\t\t\t\t\t\t\tctx.strokeStyle = ctx.fillStyle;\n\t\t\t\t\t\t\tctx.globalAlpha = alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo( x, isLumiBars ? channelTop : analyzerBottom );\n\t\t\t\t\t\tctx.lineTo( x, isLumiBars ? channelBottom : analyzerBottom - barHeight );\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t\telse if ( ! isRadial ) {\n\t\t\t\t\t\tctx.fillRect( posX, isLumiBars ? channelTop : analyzerBottom, adjWidth, isLumiBars ? channelBottom : -barHeight );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( bar.posX >= 0 ) {\n\t\t\t\t\t\tradialPoly( posX, 0, adjWidth, barHeight );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Draw peak\n\t\t\t\tif ( bar.peak[ channel ] > 1 ) { // avoid half \"negative\" peaks on top channel (peak height is 2px)\n\t\t\t\t\tif ( this.showPeaks && ! isLumiBars ) {\n\t\t\t\t\t\tif ( isLedDisplay ) {\n\t\t\t\t\t\t\t// convert the bar height to the position of the corresponding led element\n\t\t\t\t\t\t\tconst fullLeds = bar.peak[ channel ] / ( analyzerHeight + ledSpaceV ) * ledCount | 0,\n\t\t\t\t\t\t\t\t  posY     = ( ledCount - fullLeds - 1 ) * ( ledHeight + ledSpaceV );\n\n\t\t\t\t\t\t\tctx.fillRect( posX,\tchannelTop + posY, width, ledHeight );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( ! isRadial ) {\n\t\t\t\t\t\t\tctx.fillRect( posX, analyzerBottom - bar.peak[ channel ], adjWidth, 2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( mode != 10 && bar.posX >= 0 ) { // radial - no peaks for mode 10 or wrap-around frequencies\n\t\t\t\t\t\t\tradialPoly( posX, bar.peak[ channel ] * ( channel == 1 ? -1 : 1 ), adjWidth, -2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( bar.hold[ channel ] )\n\t\t\t\t\t\tbar.hold[ channel ]--;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbar.accel[ channel ]++;\n\t\t\t\t\t\tbar.peak[ channel ] -= bar.accel[ channel ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // for ( let i = 0; i < nBars; i++ )\n\n\t\t\t// restore global alpha\n\t\t\tctx.globalAlpha = 1;\n\n\t\t\t// Fill/stroke drawing path for mode 10 and radial\n\t\t\tif ( mode == 10 ) {\n\t\t\t\tif ( isRadial )\n\t\t\t\t\tctx.closePath();\n\t\t\t\telse\n\t\t\t\t\tctx.lineTo( canvas.width + this.lineWidth, analyzerBottom );\n\n\t\t\t\tif ( this.lineWidth > 0 ) {\n\t\t\t\t\tctx.lineWidth = this.lineWidth;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\n\t\t\t\tif ( this.fillAlpha > 0 ) {\n\t\t\t\t\tif ( isRadial ) {\n\t\t\t\t\t\t// exclude the center circle from the fill area\n\t\t\t\t\t\tctx.moveTo( centerX + radius, centerY );\n\t\t\t\t\t\tctx.arc( centerX, centerY, radius, 0, TAU, true );\n\t\t\t\t\t}\n\t\t\t\t\tctx.globalAlpha = this.fillAlpha;\n\t\t\t\t\tctx.fill();\n\t\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( isRadial ) {\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\t// Reflex effect\n\t\t\tif ( this._reflexRatio > 0 && ! isLumiBars ) {\n\t\t\t\tlet posY, height;\n\t\t\t\tif ( this.reflexFit || isStereo ) { // always fit reflex in stereo mode\n\t\t\t\t\tposY   = isStereo && channel == 0 ? channelHeight + channelGap : 0;\n\t\t\t\t\theight = channelHeight - analyzerHeight;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposY   = canvas.height - analyzerHeight * 2;\n\t\t\t\t\theight = analyzerHeight;\n\t\t\t\t}\n\n\t\t\t\t// set alpha and brightness for the reflection\n\t\t\t\tctx.globalAlpha = this.reflexAlpha;\n\t\t\t\tif ( this.reflexBright != 1 )\n\t\t\t\t\tctx.filter = `brightness(${this.reflexBright})`;\n\n\t\t\t\t// create the reflection\n\t\t\t\tctx.setTransform( 1, 0, 0, -1, 0, canvas.height );\n\t\t\t\tctx.drawImage( canvas, 0, channelTop, canvas.width, analyzerHeight, 0, posY, canvas.width, height );\n\n\t\t\t\t// reset changed properties\n\t\t\t\tctx.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\t\t\tctx.filter = 'none';\n\t\t\t\tctx.globalAlpha = 1;\n\t\t\t}\n\n\t\t} // for ( let channel = 0; channel < isStereo + 1; channel++ ) {\n\n\t\t// Update energy\n\t\tenergy.val = currentEnergy / ( nBars << isStereo );\n\t\tif ( energy.val >= energy.peak ) {\n\t\t\tenergy.peak = energy.val;\n\t\t\tenergy.hold = 30;\n\t\t}\n\t\telse {\n\t\t\tif ( energy.hold > 0 )\n\t\t\t\tenergy.hold--;\n\t\t\telse if ( energy.peak > 0 )\n\t\t\t\tenergy.peak *= ( 30 + energy.hold-- ) / 30; // decay (drops to zero in 30 frames)\n\t\t}\n\n\t\t// restore solid lines\n\t\tctx.setLineDash([]);\n\n\t\t// draw frequency scale (X-axis)\n\t\tif ( this.showScaleX ) {\n\t\t\tif ( isRadial ) {\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate( centerX, centerY );\n\t\t\t\tif ( this._spinSpeed != 0 )\n\t\t\t\t\tctx.rotate( this._spinAngle + HALF_PI );\n\t\t\t\tctx.drawImage( canvasR, -canvasR.width >> 1, -canvasR.width >> 1 );\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t\telse\n\t\t\t\tctx.drawImage( canvasX, 0, canvas.height - canvasX.height );\n\t\t}\n\n\t\t// calculate and update current frame rate\n\n\t\tthis._frame++;\n\t\tconst elapsed = timestamp - this._time;\n\n\t\tif ( elapsed >= 1000 ) {\n\t\t\tthis._fps = this._frame / ( elapsed / 1000 );\n\t\t\tthis._frame = 0;\n\t\t\tthis._time = timestamp;\n\t\t}\n\t\tif ( this.showFPS ) {\n\t\t\tconst size = canvasX.height;\n\t\t\tctx.font = `bold ${size}px sans-serif`;\n\t\t\tctx.fillStyle = '#0f0';\n\t\t\tctx.textAlign = 'right';\n\t\t\tctx.fillText( Math.round( this._fps ), canvas.width - size, size * 2 );\n\t\t}\n\n\t\t// call callback function, if defined\n\t\tif ( this.onCanvasDraw ) {\n\t\t\tctx.save();\n\t\t\tctx.fillStyle = ctx.strokeStyle = this._canvasGradient;\n\t\t\tthis.onCanvasDraw( this );\n\t\t\tctx.restore();\n\t\t}\n\n\t\t// schedule next canvas update\n\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) );\n\t}\n\n\t/**\n\t * Generate currently selected gradient\n\t */\n\t_makeGrad() {\n\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst ctx            = this._canvasCtx,\n\t\t\t  canvas         = ctx.canvas,\n\t\t\t  isLumiBars     = this._isLumiBars,\n\t\t\t  gradientHeight = isLumiBars ? canvas.height : canvas.height * ( 1 - this._reflexRatio * ! this._stereo ) | 0,\n\t\t\t  \t\t\t\t\t// for stereo we keep the full canvas height and handle the reflex areas while generating the color stops\n\t\t\t  analyzerRatio  = 1 - this._reflexRatio;\n\n\t\t// for radial mode\n\t\tconst centerX = canvas.width >> 1,\n\t\t\t  centerY = canvas.height >> 1,\n\t\t\t  radius  = this._radius;\n\n\t\tconst currGradient = this._gradients[ this._gradient ],\n\t\t\t  colorStops   = currGradient.colorStops,\n\t\t\t  isHorizontal = currGradient.dir == 'h';\n\n\t\tlet grad;\n\n\t\tif ( this._radial )\n\t\t\tgrad = ctx.createRadialGradient( centerX, centerY, centerY, centerX, centerY, radius - ( centerY - radius ) * this._stereo );\n\t\telse\n\t\t\tgrad = ctx.createLinearGradient( 0, 0, isHorizontal ? canvas.width : 0, isHorizontal ? 0 : gradientHeight );\n\n\t\tif ( colorStops ) {\n\t\t\tconst dual = this._stereo && ! this._splitGradient && ! isHorizontal;\n\n\t\t\t// helper function\n\t\t\tconst addColorStop = ( offset, colorInfo ) => grad.addColorStop( offset, colorInfo.color || colorInfo );\n\n\t\t\tfor ( let channel = 0; channel < 1 + dual; channel++ ) {\n\t\t\t\tcolorStops.forEach( ( colorInfo, index ) => {\n\n\t\t\t\t\tconst maxIndex = colorStops.length - 1;\n\n\t\t\t\t\tlet offset = colorInfo.pos !== undefined ? colorInfo.pos : index / maxIndex;\n\n\t\t\t\t\t// in dual mode (not split), use half the original offset for each channel\n\t\t\t\t\tif ( dual )\n\t\t\t\t\t\toffset /= 2;\n\n\t\t\t\t\t// constrain the offset within the useful analyzer areas (avoid reflex areas)\n\t\t\t\t\tif ( this._stereo && ! isLumiBars && ! this._radial && ! isHorizontal ) {\n\t\t\t\t\t\toffset *= analyzerRatio;\n\t\t\t\t\t\t// skip the first reflex area in split mode\n\t\t\t\t\t\tif ( ! dual && offset > .5 * analyzerRatio )\n\t\t\t\t\t\t\toffset += .5 * this._reflexRatio;\n\t\t\t\t\t}\n\n\t\t\t\t\t// only for split mode\n\t\t\t\t\tif ( channel == 1 ) {\n\t\t\t\t\t\t// add colors in reverse order if radial or lumi are active\n\t\t\t\t\t\tif ( this._radial || isLumiBars ) {\n\t\t\t\t\t\t\tconst revIndex = maxIndex - index;\n\t\t\t\t\t\t\tcolorInfo = colorStops[ revIndex ];\n\t\t\t\t\t\t\toffset = 1 - ( colorInfo.pos !== undefined ? colorInfo.pos : revIndex / maxIndex ) / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// if the first offset is not 0, create an additional color stop to prevent bleeding from the first channel\n\t\t\t\t\t\t\tif ( index == 0 && offset > 0 )\n\t\t\t\t\t\t\t\taddColorStop( .5, colorInfo );\n\t\t\t\t\t\t\t// bump the offset to the second half of the gradient\n\t\t\t\t\t\t\toffset += .5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add gradient color stop\n\t\t\t\t\taddColorStop( offset, colorInfo );\n\n\t\t\t\t\t// create additional color stop at the end of first channel to prevent bleeding\n\t\t\t\t\tif ( this._stereo && index == maxIndex && offset < .5 )\n\t\t\t\t\t\taddColorStop( .5, colorInfo );\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis._canvasGradient = grad;\n\t}\n\n\t/**\n\t * Generate the X-axis and radial scales in auxiliary canvases\n\t */\n\t_createScales() {\n\t\tconst freqLabels  = [ 16, 31, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000 ],\n\t\t\t  canvas      = this._canvasCtx.canvas,\n\t\t\t  scaleX      = this._scaleX,\n\t\t\t  scaleR      = this._scaleR,\n\t\t\t  canvasX     = scaleX.canvas,\n\t\t\t  canvasR     = scaleR.canvas,\n\t\t\t  scaleHeight = canvas.height * .03 | 0; // circular scale height (radial mode)\n\n\t\t// in radial stereo mode, the scale is positioned exactly between both channels, by making the canvas a bit larger than the central diameter\n\t\tcanvasR.width = canvasR.height = ( this._radius << 1 ) + ( this._stereo * scaleHeight );\n\n\t\tconst radius  = canvasR.width >> 1, // this is also used as the center X and Y coordinates of the circular scale canvas\n\t\t\t  radialY = radius - scaleHeight * .7;\t// vertical position of text labels in the circular scale\n\n\t\t// clear scale canvas\n\t\tcanvasX.width |= 0;\n\n\t\tscaleX.fillStyle = scaleR.strokeStyle = '#000c';\n\t\tscaleX.fillRect( 0, 0, canvasX.width, canvasX.height );\n\n\t\tscaleR.arc( radius, radius, radius - scaleHeight / 2, 0, TAU );\n\t\tscaleR.lineWidth = scaleHeight;\n\t\tscaleR.stroke();\n\n\t\tscaleX.fillStyle = scaleR.fillStyle = '#fff';\n\t\tscaleX.font = `${ canvasX.height >> 1 }px sans-serif`;\n\t\tscaleR.font = `${ scaleHeight >> 1 }px sans-serif`;\n\t\tscaleX.textAlign = scaleR.textAlign = 'center';\n\n\t\tfor ( const freq of freqLabels ) {\n\t\t\tconst label = ( freq >= 1000 ) ? `${ freq / 1000 }k` : freq,\n\t\t\t\t  x     = this._logWidth * ( Math.log10( freq ) - this._minLog );\n\n\t\t\tscaleX.fillText( label, x, canvasX.height * .75 );\n\n\t\t\t// avoid overlapping wrap-around labels in the circular scale\n\t\t\tif ( x > 0 && x < canvas.width ) {\n\t\t\t\tconst angle  = TAU * ( x / canvas.width ),\n\t\t\t\t\t  adjAng = angle - HALF_PI, // rotate angles so 0 is at the top\n\t\t\t\t\t  posX   = radialY * Math.cos( adjAng ),\n\t\t\t\t\t  posY   = radialY * Math.sin( adjAng );\n\n\t\t\t\tscaleR.save();\n\t\t\t\tscaleR.translate( radius + posX, radius + posY );\n\t\t\t\tscaleR.rotate( angle );\n\t\t\t\tscaleR.fillText( label, 0, 0 );\n\t\t\t\tscaleR.restore();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Precalculate the actual X-coordinate on screen for each analyzer bar\n\t *\n\t * Since the frequency scale is logarithmic, each position in the X-axis actually represents a power of 10.\n\t * To improve performace, the position of each frequency is calculated in advance and stored in an array.\n\t * Canvas space usage is optimized to accommodate exactly the frequency range the user needs.\n\t * Positions need to be recalculated whenever the frequency range, FFT size or canvas size change.\n\t *\n\t *                              +-------------------------- canvas --------------------------+\n\t *                              |                                                            |\n\t *    |-------------------|-----|-------------|-------------------!-------------------|------|------------|\n\t *    1                  10     |            100                  1K                 10K     |           100K (Hz)\n\t * (10^0)              (10^1)   |          (10^2)               (10^3)              (10^4)   |          (10^5)\n\t *                              |-------------|<--- logWidth ---->|--------------------------|\n\t *                  minFreq--> 20                   (pixels)                                22K <--maxFreq\n\t *                          (10^1.3)                                                     (10^4.34)\n\t *                           minLog\n\t */\n\t_calcBars() {\n\n\t\tconst bars = this._bars = []; // initialize object property\n\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\t// helper function\n\t\tconst binToFreq = bin => bin * this.audioCtx.sampleRate / this._analyzer[0].fftSize;\n\n\t\tconst canvas  = this._canvasCtx.canvas,\n\t\t\t  maxFreq = this._maxFreq,\n\t\t\t  minFreq = this._minFreq;\n\n\t\tlet minLog,\tlogWidth;\n\n\t\tif ( ! this._isOctaveBands ) {\n\t\t// Discrete frequencies or area fill modes\n\t\t\tthis._barWidth = 1;\n\n\t\t\tminLog = Math.log10( minFreq );\n\t\t\tlogWidth = canvas.width / ( Math.log10( maxFreq ) - minLog );\n\n\t\t\tconst minIndex = this._freqToBin( minFreq, 'floor' ),\n\t\t\t\t  maxIndex = this._freqToBin( maxFreq );\n\n\t \t\tlet lastPos = -999;\n\n\t\t\tfor ( let i = minIndex; i <= maxIndex; i++ ) {\n\t\t\t\tconst freq = binToFreq( i ), // frequency represented by this index\n\t\t\t\t\t  pos  = Math.round( logWidth * ( Math.log10( freq ) - minLog ) ); // avoid fractionary pixel values\n\n\t\t\t\t// if it's on a different X-coordinate, create a new bar for this frequency\n\t\t\t\tif ( pos > lastPos ) {\n\t\t\t\t\tbars.push( { posX: pos, dataIdx: i, endIdx: 0, factor: 0, peak: [0,0], hold: [], accel: [] } );\n\t\t\t\t\tlastPos = pos;\n\t\t\t\t} // otherwise, add this frequency to the last bar's range\n\t\t\t\telse if ( bars.length )\n\t\t\t\t\tbars[ bars.length - 1 ].endIdx = i;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t// Octave bands modes\n\n\t\t\t// generate a table of frequencies based on the equal tempered scale\n\n\t\t\tconst notesPerBand = [0,1,2,3,4,6,8,12,24][ this._mode ];\n\n\t\t\tlet i = 0,\n\t\t\t\tfreq,\n\t\t\t\ttemperedScale = [];\n\n\t\t\twhile ( ( freq = C0 * ROOT24 ** i ) <= maxFreq ) {\n\t\t\t\tif ( freq >= minFreq && i % notesPerBand == 0 )\n\t\t\t\t\ttemperedScale.push( freq );\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tminLog = Math.log10( temperedScale[0] );\n\t\t\tlogWidth = canvas.width / ( Math.log10( temperedScale[ temperedScale.length - 1 ] ) - minLog );\n\n\t\t\t// divide canvas space by the number of frequencies (bars) to display\n\t\t\tthis._barWidth = canvas.width / temperedScale.length;\n\n\t\t\tlet prevBin = 0,  // last bin included in previous frequency band\n\t\t\t\tprevIdx = -1, // previous bar FFT array index\n\t\t\t\tnBars   = 0;  // count of bars with the same index\n\n\t\t\ttemperedScale.forEach( ( freq, index ) => {\n\t\t\t\t// which FFT bin best represents this frequency?\n\t\t\t\tconst bin = this._freqToBin( freq );\n\n\t\t\t\tlet idx, nextBin;\n\t\t\t\t// start from the last used FFT bin\n\t\t\t\tif ( prevBin > 0 && prevBin + 1 <= bin )\n\t\t\t\t\tidx = prevBin + 1;\n\t\t\t\telse\n\t\t\t\t\tidx = bin;\n\n\t\t\t\t// FFT does not provide many coefficients for low frequencies, so several bars may end up using the same data\n\t\t\t\tif ( idx == prevIdx ) {\n\t\t\t\t\tnBars++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// update previous bars using the same index with a interpolation factor\n\t\t\t\t\tif ( nBars > 1 ) {\n\t\t\t\t\t\tfor ( let i = 0; i < nBars; i++ )\n\t\t\t\t\t\t\tbars[ bars.length - nBars + i ].factor = ( i + 1 ) / nBars;\n\t\t\t\t\t}\n\t\t\t\t\tprevIdx = idx;\n\t\t\t\t\tnBars = 1;\n\t\t\t\t}\n\n\t\t\t\tprevBin = nextBin = bin;\n\t\t\t\t// check if there's another band after this one\n\t\t\t\tif ( index < temperedScale.length - 1 ) {\n\t\t\t\t\tnextBin = this._freqToBin( temperedScale[ index + 1 ] );\n\t\t\t\t\t// and use half the bins in between for this band\n\t\t\t\t\tif ( nextBin - bin > 1 )\n\t\t\t\t\t\tprevBin += Math.round( ( nextBin - bin ) / 2 );\n\t\t\t\t}\n\n\t\t\t\tconst endIdx = prevBin - idx > 0 ? prevBin : 0;\n\n\t\t\t\tbars.push( {\n\t\t\t\t\tposX: index * this._barWidth,\n\t\t\t\t\tdataIdx: idx,\n\t\t\t\t\tendIdx,\n\t\t\t\t\tfactor: 0,\n\t\t\t\t\tpeak: [0,0],\n\t\t\t\t\thold: [],\n\t\t\t\t\taccel: []\n\t\t\t\t} );\n\n\t\t\t} );\n\t\t}\n\n\t\t// save these for scale generation\n\t\tthis._minLog = minLog;\n\t\tthis._logWidth = logWidth;\n\n\t\t// update internal variables\n\t\tthis._calcAux();\n\n\t\t// generate the X-axis and radial scales\n\t\tthis._createScales();\n\n\t\t// update LED properties\n\t\tthis._calcLeds();\n\t}\n\n\t/**\n\t * Return the FFT data bin (array index) which represents a given frequency\n\t */\n\t_freqToBin( freq, rounding = 'round' ) {\n\t\tconst max = this._analyzer[0].frequencyBinCount - 1,\n\t\t\t  bin = Math[ rounding ]( freq * this._analyzer[0].fftSize / this.audioCtx.sampleRate );\n\n\t\treturn bin < max ? bin : max;\n\t}\n\n\t/**\n\t * Internal function to change canvas dimensions on demand\n\t */\n\t_setCanvas( reason ) {\n\t\t// if initialization is not finished, quit\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst ctx    = this._canvasCtx,\n\t\t\t  canvas = ctx.canvas;\n\n\t\tthis._pixelRatio = window.devicePixelRatio; // for Retina / HiDPI devices\n\n\t\tif ( this._loRes )\n\t\t\tthis._pixelRatio /= 2;\n\n\t\tthis._fsWidth = Math.max( window.screen.width, window.screen.height ) * this._pixelRatio;\n\t\tthis._fsHeight = Math.min( window.screen.height, window.screen.width ) * this._pixelRatio;\n\n\t\tconst isFullscreen = this.isFullscreen,\n\t\t\t  newWidth  = isFullscreen ? this._fsWidth  : ( this._width  || this._container.clientWidth  || this._defaultWidth )  * this._pixelRatio | 0,\n\t\t\t  newHeight = isFullscreen ? this._fsHeight : ( this._height || this._container.clientHeight || this._defaultHeight ) * this._pixelRatio | 0;\n\n\t\t// if canvas dimensions haven't changed, quit\n\t\tif ( canvas.width == newWidth && canvas.height == newHeight )\n\t\t\treturn;\n\n\t\t// apply new dimensions\n\t\tcanvas.width  = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\t// update internal variables\n\t\tthis._calcAux();\n\n\t\t// if not in overlay mode, paint the canvas black\n\t\tif ( ! this.overlay ) {\n\t\t\tctx.fillStyle = '#000';\n\t\t\tctx.fillRect( 0, 0, canvas.width, canvas.height );\n\t\t}\n\n\t\t// set lineJoin property for area fill mode (this is reset whenever the canvas size changes)\n\t\tctx.lineJoin = 'bevel';\n\n\t\t// update dimensions of the scale canvas\n\t\tconst canvasX = this._scaleX.canvas;\n\t\tcanvasX.width = canvas.width;\n\t\tcanvasX.height = Math.max( 20 * this._pixelRatio, canvas.height / 27 | 0 );\n\n\t\t// (re)generate gradient\n\t\tthis._makeGrad();\n\n\t\t// calculate bar positions and led options\n\t\tthis._calcBars();\n\n\t\t// detect fullscreen changes (for Safari)\n\t\tif ( this._fsStatus !== undefined && this._fsStatus !== isFullscreen )\n\t\t\treason = 'fschange';\n\t\tthis._fsStatus = isFullscreen;\n\n\t\t// call the callback function, if defined\n\t\tif ( this.onCanvasResize )\n\t\t\tthis.onCanvasResize( reason, this );\n\t}\n\n\t/**\n\t * Set object properties\n\t */\n\t_setProps( options, useDefaults ) {\n\n\t\t// settings defaults\n\t\tconst defaults = {\n\t\t\tmode         : 0,\n\t\t\tfftSize      : 8192,\n\t\t\tminFreq      : 20,\n\t\t\tmaxFreq      : 22000,\n\t\t\tsmoothing    : 0.5,\n\t\t\tgradient     : 'classic',\n\t\t\tminDecibels  : -85,\n\t\t\tmaxDecibels  : -25,\n\t\t\tshowBgColor  : true,\n\t\t\tshowLeds     : false,\n\t\t\tshowScaleX   : true,\n\t\t\tshowScaleY   : false,\n\t\t\tshowPeaks    : true,\n\t\t\tshowFPS      : false,\n\t\t\tlumiBars     : false,\n\t\t\tloRes        : false,\n\t\t\treflexRatio  : 0,\n\t\t\treflexAlpha  : 0.15,\n\t\t\treflexBright : 1,\n\t\t\treflexFit    : true,\n\t\t\tlineWidth    : 0,\n\t\t\tfillAlpha    : 1,\n\t\t\tbarSpace     : 0.1,\n\t\t\toverlay      : false,\n\t\t\tbgAlpha      : 0.7,\n\t\t\tradial\t\t : false,\n\t\t\tspinSpeed    : 0,\n\t\t\tstereo       : false,\n\t\t\tsplitGradient: false,\n\t\t\tstart        : true,\n\t\t\tvolume       : 1\n\t\t};\n\n\t\t// callback functions properties\n\t\tconst callbacks = [ 'onCanvasDraw', 'onCanvasResize' ];\n\n\t\t// compile valid properties; `start` is not an actual property and is handled after setting everything else\n\t\tconst validProps = Object.keys( defaults ).concat( callbacks, ['height', 'width'] ).filter( e => e != 'start' );\n\n\t\tif ( useDefaults || options === undefined )\n\t\t\toptions = Object.assign( defaults, options ); // NOTE: defaults is modified!\n\n\t\tfor ( const prop of Object.keys( options ) ) {\n\t\t\tif ( callbacks.includes( prop ) && typeof options[ prop ] !== 'function' ) // check invalid callback\n\t\t\t\tthis[ prop ] = undefined;\n\t\t\telse if ( validProps.includes( prop ) ) // set only valid properties\n\t\t\t\tthis[ prop ] = options[ prop ];\n\t\t}\n\n\t\tif ( options.start !== undefined )\n\t\t\tthis.toggleAnalyzer( options.start );\n\t}\n\n}\n\n/* Custom error class */\n\nclass AudioMotionError extends Error {\n\tconstructor( code, message ) {\n\t\tsuper( message );\n\t\tthis.name = 'AudioMotionError';\n\t\tthis.code = code;\n\t}\n}\n","import AudioMotionAnalyzer from \"audiomotion-analyzer\";\n// audio source\nconst audioElA = document.getElementById(\"audioA\");\nconst audioElB = document.getElementById(\"audioB\");\n\n// instantiate analyzer\nconst audiomotion = new AudioMotionAnalyzer(\n  document.getElementById(\"containerMain\"),\n  {\n    height: window.innerHeight - 50,\n    mode: 1,\n    barSpace: 0.6,\n    showLeds: true\n  }\n);\nconst AnalyserA = new AudioMotionAnalyzer(\n  document.getElementById(\"containerA\"),\n  {\n    height: window.innerHeight - 50,\n    mode: 0,\n    barSpace: 0.6,\n    showLeds: true\n    //connectSpeakers: false\n  }\n);\nconst AnalyserB = new AudioMotionAnalyzer(\n  document.getElementById(\"containerB\"),\n  {\n    height: window.innerHeight - 50,\n    mode: 0,\n    barSpace: 0.6,\n    showLeds: true\n    //connectSpeakers: false\n  }\n);\n\n// file upload 1\ndocument.getElementById(\"TrackA\").addEventListener(\"change\", (e) => {\n  let fileBlob = e.target.files[0];\n  if (fileBlob) {\n    audioElA.src = \"\";\n    AnalyserA.disconnectInput(audioElA);\n    var filename = $(\"#TrackA\")\n      .val()\n      .replace(/.*(\\/|\\\\)/, \"\");\n    document.getElementById(\"Track1Name\").innerText = \"\";\n    document.getElementById(\"Track1Name\").innerText =\n      \"Current Track: \" + filename;\n    audioElA.src = URL.createObjectURL(fileBlob);\n    AnalyserA.connectInput(audioElA);\n    //AnalyserA.connectOutput(master);\n    audioElA.play();\n  }\n});\n\n// file upload 2\ndocument.getElementById(\"TrackB\").addEventListener(\"change\", (e) => {\n  let fileBlob = e.target.files[0];\n  if (fileBlob) {\n    audioElB.src = \"\";\n    AnalyserB.disconnectInput(audioElB);\n    var filename = $(\"#TrackB\")\n      .val()\n      .replace(/.*(\\/|\\\\)/, \"\");\n    document.getElementById(\"Track2Name\").innerText = \"\";\n    document.getElementById(\"Track2Name\").innerText =\n      \"Current Track: \" + filename;\n    audioElB.src = URL.createObjectURL(fileBlob);\n    AnalyserB.connectInput(audioElB);\n    //AnalyserB.connectOutput(master);\n    audioElB.play();\n  }\n});\n\n/*$(\"#pushtrack1\").click(function () {\n  AnalyserA.disconnectInput();\n  $(\"#recalltrack1\").css(\"display\", \"flex\");\n});\n\n$(\"#pushtrack2\").click(function () {\n  AnalyserB.disconnectInput();\n  $(this).css(\"display\", \"none\");\n  $(\"#recalltrack2\").css(\"display\", \"flex\");\n});*/\n"]}